
java的优势：
    （1）结构严谨、面向对象
    （2）跨平台
    （3）提供安全的内存管理和访问机制，避免了大部分的内存泄漏和指针越界问题
    （4）热点代码检测和运行时编译提高性能
JDK：
    Java语言、JVM、Java类库，或者可以视为整个Java技术体系
JRE：
    支持Java程序运行的标准环境，JVM　+ java类库中的SE子集

运行时数据分区：
    （1）程序计数器：
        ·空间较小， 线程私有
        .线程执行字节码的行号指示， 如果是执行Native方法则为空
    （2）Java虚拟机栈：
        .线程私有，生命周期同线程， 是线程执行的内存模式
        .每一个方法被执行的时候会生成一个栈帧，保存局部变量表（局部变量槽slot）、操作数栈、动态链接、方法出口等
        .如果线程请求的栈深度超多JVM允许活物理容量，会抛出异常StackOverFlowError
    （3）本地方法栈
        .同虚拟机栈， 只不过是Native方法执行的内存模型，也会有溢出的异常
    （4）Java堆
        .空间最大，线程共享
        .用于存放对象实例，物理上可以是不连续的空间，但是逻辑上被视为连续的
        .可以允许扩展， 超出容量限制后报错OutOfMemoryError
        .GC回收的重点也是难点， 因为较之于栈，对象什么时候该回收更不确定
    （5）方法区
        线程共享
        存储加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等
        可以选择不进行GC， 但超出容量也会产生OOM
    （6）运行时常量池
        属于方法区的一部分， class文件中的常量池表（字面量、符号引用）存放在这里

    （7）直接内存
        理论上不属于运行时数据区，但是如果不注意也会产生OOM
        NIO中引入基于通道和缓存区的I/O方式，使用Native函数直接分配堆外内存，通过堆内的DirectByteBuffer对象进行操作，避免再native堆和Java堆中来回赋值数据提高性能


对象创建的过程：
    （1）查看常量池是否能定位到一个类的引用， 没有的话需要进行类加载
    （2）分配内存：内存分配需要考虑两个问题
            （1）内存如何分配：比较规则的内存使用指针碰撞， 不规整的使用空闲列表，后者较为复杂，空间是否规整则依赖于垃圾收集器是否具有压缩整理的能力（Compact）
                比如Serial、ParNew & CMS
            （2）内存分配如何解决同步问题： CAS 或者 提前个线程分配预留空间（本地线程分配缓存， TLAB）
    （3）设置对象头：类元信息、哈希码、GC年代、偏向锁等
    （4）构造函数初始化，即执行Class文件的的<INIT>方法


对象的内存布局：
        （1）对象头：
                （1）MarkWord: 存储对象运行数据，哈希码、GC分代年龄、锁标志状态、偏向线程ID等
                （2）类型指针：指向类元数据的指针
        （2）实例数据：
        （3）对齐填充：无特殊含义， 因为要求对象起始地址是8字节的整数倍

判断对象回收的思路：
        （1）引用计数：需要额外的内存和维护操作，并且对于存在相互依赖关系的情况也没法有效回收， java中几乎没有使用
        （2）可达性分析：基于一系列GC roots作为起始节点，根据引用关系向下搜素，凡是引用链上的对象都是不能回收的
            以下这些可以作为root节点：
                （1）虚拟机栈中引用的对象
                （2）方法区中静态属性引用的对象、常量引用的对象
                （3）类似的，本地方法中引用的对象
                （4）虚拟机内部引用的常用对象比如class、异常对象等
                （5）被同步锁持有的对象。。。
            枚举根节点的操作是会产生停顿的， 即停止所有用户线程

引用类型：
    （1）强引用：发生 gc 的时候不会被回收。
    （2）软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。
    （3）弱引用：有用但不是必须的对象，在下一次GC时会被回收。
    （4）虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。


finalize()
        可达性分析算法判断需要回收的对象不会被立即回收， 而是之后会执行finalize（）方法， 如果执行期间和其他对象产生关联可以逃避回收，这个方法只执行一次后续无法在逃脱
        实际应用中不推荐通过这种方式来玩！



分代垃圾回收的两个重要基本假设：
    （1）大部分对象存活周期很短
    （2）熬过过次GC的对象大概率会一直存活
    （3）跨代引用的情况相对来讲比较少
    分代回收的一个重要问题是：
        对象之间引用关系复杂， 如何处理跨代的对象

主要涉及回收算法：
    （1）标记-清除：
        效率不稳定， 内存碎片
    （2）标记-复制：半区复制
        空间浪费，适用于大多数对象需要回收的场景， 存活率较高时候复制会影响性能
        实际上也不需要按1：1来分配使用和未使用区域，hotSpot中的Eden 和 2个Survive区， 比例是8：1， 每次都将一个使用的Survive和Eden中存活的对象放在另一个未使用的survive上
        如果剩余的survive不够则这些对象直接进入老年代区域称为分配担保
    （3）标记整理算法：
        标记清除后，让所有存活的对象向内存一侧移动，消除碎片
        但是整理中涉及对象移动也会产生负担，并且需要暂停用户应用程序，可能会产生一定延时，不过整体吞吐量应该是会增加
        因此Parallel scavenge关注吞吐量使用的是标记整理算法
        CMS关注时延使用标记清除算法

安全点和安全区域
    因为停顿的影响很大， 所有一般是等所有线程都进去安全点或者安全区域（引用关系不会发生变化的代码片段）后再停顿


常见收集器：
    （1）Serial/Serial Old：
            简单高效， 占据额外内存少
            单线程，工作的是偶需要暂停所有用户线程
            新生代使用复制算法， 老生代使用标记整理算法
            Serial 是客户端模式下的默认新生代收集器
            可以和CMS并用
    （2）ParNew:
            可以理解为是Serial的多线程版本
            可以和CMS并用
            如果激活使用CMS，则新生代默认就是ParNew: -XX：+UseConcMarkSweepGC
    （3）CMS：
            停顿时间短
            多线程
            老生代垃圾收集器
            基于标记清除算法
            堆处理器资源比较敏感，如果核心数少的话影响吞吐量
            GC过程：
                （1）初始标记：GC Roots , 需要暂停
                （2）并发标记：引用链搜索， 不需要暂停
                （3）重新标记：修正期间发生变动的， 需要暂停
                （4）并发清除： 不需要停顿
    （4）G1 ： Garbage First
            服务端下默认收集器， 整体上基于标记整理算法，局部上使用了标记复制算法
            基于Region， 将堆划分成相同大小的独立Region， 每个Region根据需要扮演Eden或者Survivor的角色
            停顿时间可预期，用户可指定，但是内存占用也相对多了，其为了解决跨代涉及的记忆集也更大。
            Region是回收的基本单位， 每个region都有一个计算的回收价值，根据价值优先进行回收
            GC过程：
                （1）初始标记， 停顿
                （2）并发标记
                （3）最终标记， 停顿
                （4）筛选回收：region统计数据更新，回收region， 并将存活的region放在新region中
    （5）ZGC：
        目标：10毫秒以内的低延迟
            基于Region内存布局，暂时不分代、使用了读屏障、染色指针和内存多重映射技术实现的标记整理算法
            （1）Region分大中小，不是固定的
            （2）不关心对象内容，因此直接将GC标记信息记录在指针上： 64位系统支持的理论内存很高实际上完全不可能，因此实际上一般硬件支持寻址只有46位左右， 因此使用高位的4位来存储标志信息：
                当然这种扩展需要基于内存多重映射进行转换才能正常寻找址
                包括三色标记状态、是否进入重分配集、是否进入finalize才能被访问到等
                这一设计可以显著减少内存屏障的使用只使用了读屏障

常用故障监控和处理工具：
        （1）jps: 查看虚拟机进程状况，包含执行主类， 类似Unix中的ps指令
        （2）jstat: 虚拟机统计信息监视， 包括众多信息比如类加载、内存、GC、即时编译等
        （3）jinfo: 实时查看和调整虚拟机参数
        （4）jmap: 查看内存映像， 生成堆转储快照，可以查看堆和方法区的详细信息
        （5）jhat: 虚拟机堆转储快照的分析工具
        （6）jstack: 虚拟机当前线程快照（每一个线程执行方法栈的集合）
        （7）JMC、VisualVM:  可视工具

Class文件：
        一组以8字节为单位的二进制流， 中间没有任何分隔符， 每个字段的长度和位置都是严格定义好的：
            （1）魔数 + 版本号
            （2）常量池： 字面量和符号引用， 最繁琐的部分
            （3）访问标志： 类或者接口层次的访问信息，是否接口、是否抽象、是否final等等
            （4）类索引（确定类的全限定名）、父类索引（只有一个）、接口索引（实现的接口)
            （5）字段表集合：类或者接口中定义的变量（不包含方法中的局部变量）
            （6）方法表结合：
            （7）属性表集合

        注意： 编译时不会进行程序的连接，而是再执行的时候动态加载、动态连接，这也是Java动态扩展的重要特点之一。



虚拟机类加载过程：
            （1）加载：
                    （a）通过类全限定名来获取此类的二进制字节流。 获取方式可以通过自定义类加载器并重写其中的findClass()\loadClass()方法
                            压缩包获取比如JAR、WAR
                            网络中获取比如web applet
                            运行时计算生成：比如动态代理技术
                            有其他文件生成，比如JSP
                            。。。
                    （b）将字节流中代表的静态存储结构转化为方法区的运行时数据结构
                    （c）在内存中生成一个代表这个类的java.lang.Class对象，作为程序访问该类方法区数据的外部入口
            （2）连接：
                    （1）验证：
                        目标是验证Class文件的合法性和安全性主要包括
                                文件格式
                                元数据验证： 是否有父类、是否实现了抽象父类或者接口定义的方法。。。
                                字节码验证： 程序语义合法性校验， 比如类型转换是否有效
                                符号引用验证：符号引用专称直接引用
                    （2）准备：
                         将类变量（静态变量）分配内存并设置初始值（零值）， 随着class对象存储在堆中
                         如果是final静态变量则直接将初始化值赋与
                    （3）解析：
                            将常量池内存的符号引号替换成直接引用
                            直接引用是和JVM实现的内存布局相关，类或者接口的指针或者句柄

                    注意连接的三个阶段不是严格顺序执行的，而是交替同步执行的，没有严格限制

            （3）初始化：
                    从这个阶段开始真正开始执行代码，即执行类构造器的<clinit>()方法，
                        这个方法是编译器自动收集类中所有类变量的复制动作和静态语句块的语句合并而成，
                        这个方法仅仅是处理本类的变量，不需要显示调用父类构造器， 即执行子类的该方法时候，父类的该方法一定已经执行过了

类加载器：
        （1）类和其类加载器共同确定了类再JVM中的唯一性， 因为每个类加载都有一个独立的类名称空间

        （2）类加载器：可以分成两类， 一个是启动类加载器是JVM的一部分使用C++语言编写，另一类是所有其他类加载器，Java语言编写继承自Java.lang.ClassLoader
            具体包括三层：
                （1）启动类加载器：加载存放在<JAVA_HOME>\lib目录下JVM能识别的类库
                （2）扩展类加载器：<JAVA_HOME>\lib\ext目录下的类库
                （3）应用程序类加载器：加载用户路径上的所有类库
        （3）双亲委派模型：
            如果一个类加载器收到了类加载的请求，先不尝试自己加载，而是委派给父类加载器， 这样所有加载请求都会传达到启动类加载器
            如果启动类加载器不能完成加载（搜索范围内没有这个类），则交还给子加载器去执行，以此类推

            这种模型的为保证Java的程序稳定性，避免出现同一个类被多个加载器重复加载产生的混乱很重要

java编译：

    （1）.Java -> .class
           基于javac, java编写
           包括
                词法、语法分析生成语法树
                注解处理器，修改完善语法树
                生成字节码：语法糖也是在这个时候解除的
           常见的语法糖：
                （1）泛型：擦除式泛型
                （2）自动装箱拆箱
                （3）遍历循环for each
    （2）即使编译 JIT :
            字节码到机器码是通过解释器执行的， 为了提高热点代码的执行效率，JVM会将这些带代码编程成本地机器码，减少解释器的中间损耗
            主要包括C1（客户端） 和C2(服务端）两种
    （3）提前编译：
            因为即时编译需要占据内存和运算资源

Java内存模型
        变量存储在主内存：JVM内存的一部分
        每个线程有自己的工作内存，保存了主内存变量的副本
        线程对变量的操作在工作内存上，线程间变量值的传递依赖主内存
        相应的定义了8中原子操作：
            lock： 锁主内存
            unlock
            read: 读取主内存
            load： 载入工作内存
            use
            assign： 工作内存赋值
            store： 传递到主内存
            write： 写入主内存
        基本规则：
            read 和 load， store和write必须成对出现
            assign操作不能丢弃
            没有assign，则不能写回主内存

 Synchronized:
        编译后会在同步块的前后分别插入两个字节码指令：monitorenter、monitorexit
        执行monitorenter时候会尝试获取对象锁+1， monitorexit-1
        lock先比而言增加的特性：
            （1）等待可中断
            （2）可以实现公平锁
            （3）锁可以关联多个条件


















la


常用配置：
    -Xms ： 堆大小
    -Xss: 栈大小
    -XX：+HeapDumpOnOutOfMemoryError  内存堆快照
    -XX：MaxDirectMemorySize 直接内存大小
    -XX：MetaspaceSize  元数据大小
    -XX：+TraceClassLoading 查看类加载信息
    -XX：+TraceClassUnLoading 查看类卸载信息


        .



自动内存管理









内存区域
	线程执行Java方法，程序计数器值为正在执行字节码指令的地址，如果是本地方法，则为空。
	Java虚拟机栈和线程生命周期相同，每一个线程运行都会同时创建一个栈帧来保存局部变量表、操作数栈、动态链接、方法出口等；
	局部变量表中的存储空间以局部变量槽为单位，long和double占据两个，其余一个，内容是编译期间可知的基本数据类型和引用类型，空间分配（槽数量）是编译期间完成的。
	虚拟机栈有两类异常：StackOverflowError和OutOfMemoryError,如果栈不可动态扩展当请求栈深度超多分配报第一个异常，如果可以扩展但是无法申请足够内存报后者。
	堆可以是物理上不连续的内存空间，但是一般认为逻辑上是连续的；
	堆是共享的，但是从内存分配角度上，可以将堆分成多个线程私有的分配缓冲区（TLAB，thread local allocation buffer），目的是为了提升对象分配的效率。
	方法区JDK 8之前使用永久代来实现，目前已经取消，而是使用本地内存中实现的元空间（meta space）。好处是，永久代有-XX：MaxPermSize限制，容易出现OOM。
	方法区中的主要内容包括：虚拟机加载的类信息、常量、静态变量、即时编译后的代码缓存。
	虽然方法区中管理比较灵活，较少进行GC，甚至可以设置不进行GC，但也是会GC的，针对的主要是类型卸载（当加载该类型的类加载器实例(非类加载器类型)为unreachable状态时，卸载是很少发生的）和常量池回收。
	运行时常量池是方法区的一部分，类加载后，Class文件中存放编译期生成的各种字面量和符号引用（常量池表）会被存放在运行时常量池，当然运行期间也可以加入新的常量如使用String的intern()方法。
	intern()方法设计的初衷，就是重用String对象，以节省内存消耗；
	String实例调用时，去常量池查看有无该字符串值对应的常量，如果有则返回其引用，如果没有则创建一个常量，返回引用。注意new产生的对象永远是在堆中独立生成的，和常量池没有关系，但是其调用intern()方法则会创建常量。
	直接内存，并不是虚拟机运行时内存的一部分，但是常被忽略而导致虚拟机动态扩展是出现OOM；
	NIO可以使用native方法来直接分配对外内存，并在堆中存储一个DirectByteBuffer对象来对这些内存进行操作；
	直接内存的读写操作比普通Buffer快，但它的创建、销毁比普通Buffer慢，所以适合大内存空间且频繁访问的情形；
	直接内存增加也不会引起GC, 可以改善GC停顿，但是如果申请不到需要的内存，则会显示调用GC,一般会禁止显示GC, 使用参数 -XX:-+DisableExplicitGC；
	-XX:MaxDirectMemorySize 参数可以指定直接内存大小
	为什么要使用直接内存或堆外内存：通常在I/O通信过程中，会存在堆内内存到堆外内存（比如native堆）的数据拷贝操作，比如写数据，需要先将堆内数据拷贝到堆外。对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存，可以避免这样的拷贝过程带来的性能影响。
	为什么操作系统不能直接访问堆内数据呢（即不允许在堆内进行IO），这是因为GC，堆内数据虽然可能不一定为变化，但是会发生移动，地址是会变化的、不完整的，会产生许多问题。
对象
	对象创建的简单流程：检查类是否加载解析、分配空间、初始化零值、设置对象头（GC分代年龄、类元信息、哈希码，偏向锁等）、调用<init>方法执行构造函数。
	分配空间有两种主要方法：（1）指针碰撞，对于规整的堆内存，指针不断移动对象大小的空间即可，连续使用内存；（2）空闲列表，内存不规整则可以通过维护这个列表来分配；是否规整则和垃圾收集器是否带有压缩整理的功能有关，比如CMS采用标记清除算法，理论上只能使用空闲列表；
	分配空间如何保证线程安全也有两种方法：（1）CAS + 失败重试的同步处理；（2）TLAB使用。是否使用TLAB可以通过参数 –XX:+/-UseTALB 进行设置；
	对象内存布局包括三部分：对象头、实例数据、对齐填充
	对象头：存储对象自身运行时数据，哈希码、GC分代年龄、锁状态标志、线程持有的索、偏向线程的ID、偏向时间戳等，大小为64bit或32bit（实际上是动态的数据结构，以最小空间存储）称为markword，以及存储类型元数据的指针，对象头总大小为8字节的倍数、对于数组对象还包括数组长度的信息。
	实例数据存储顺序根据虚拟机分配策略（-XX:FieldAllocationStyle）以及源码定义顺序确定，原则是同类型数据集中存储
	对齐填充要求对象起始地址为8字节的倍数；
	操作访问对象是通过栈中reference数据实现的，reference有两种：（1）句柄，存储的句柄包含对象实例数据和类型数据的指针，句柄是一个存储在句柄池中的整数，reference存储的是句柄的地址。（2）直接指针，reference就是对象地址；后者主要使用，且速度更快。句柄需要间接访问稍慢，不过当对象移动时只需要更新句柄而不需要更新reference.
OOM
	出现OOM,首先需要分析是内存泄漏（分析GC roots）,还是内存溢出
	出现OOM, 可以生成堆内存转储文件来进行分析（hprof格式），使用参数：-XX:+HeapDumpOnOutOfMemoryError , 结果可以使用Eclipse的Memory Analyze Tools (MAT)或IDEA支持的VisualVM工具来分析。
	栈大小设置：-Xss
	HotSpot栈不支持动态扩展，所以一般报错都是StackOverflowError；
	出现栈溢出的原因主要有两个：大量方法调用超过栈深度，或者方法中局部变量过多超过栈帧内存分配的大小。而出现OOM的原因可能是因为多线程导致的，这时候如果栈较大反而容易出现OOM.
	方法区的溢出主要是常量池和元数据的溢出，由于JDK8以来，字符创常量池移到堆上了，相应的永久代空间设置不会导致常量池的溢出，而类元数据的溢出则除主要和动态类的产生有关也较少。
	元空间大小设置：-XX:MaxMetaspaceSize (最大)、-XX:MetaspaceSize(初始)、-XX:MinMetaspaceFreeRatio(空余最小占比)、-XX:MaxMetaspaceFreeRatio(空余最大占比)。
	直接内存溢出无法再堆转储文件中看出，分配可以通过DirectByteBuffer类也可以直接通过本地方法Unsafe（反射获得实例）的allocateMemory()方法。
垃圾收集算法
	引用技术法的问题是：循环引用无法解决
	可以作为GC Roots的对象包括：虚拟机栈中的引用、方法区中静态属性和常量引用的对象、本地方法栈中JNI引用的对象、虚拟机内部引用的对象比如class对象和常驻的异常对象、synchronized同步的锁等。
	GC Roots 大小可以进行限制已满足局部回收的需求；
	通常讲的引用即为强引用，不会被回收，此外还有：软引用，有用非必须，OOM要出现时才将这类引用回收以释放内存；弱引用，下一次GC会被回收不论内存是否充足；虚引用，无法通过虚引用访问对象实例，且引用存在不影响对象是否被回收，目的是在对象回收时可以收到一个系统通知；
	对象经有可达性分析被标记为不可达，并不立即被回收，而是会之后判断该对象是否有必要执行finalize()方法（方法未被重写或已经执行过一次则没有必要），有必要则放在F-Queue中，等待第二次标记，期间可以通过和其它对象建立关联逃脱回收，但是利用finalize()相关操作并不推荐；
	方法区回收的性价比较低，主要是废弃的常量和不再使用的类型
	类型卸载要求：所有实例均被回收、类加载器被回收、类的Class对象被回收，且不是所有垃圾收集器都实现了类卸载的功能
	在大量使用反射、动态代理、CGLib等字节码框架, 动态生成JSP以及OSGi这类频繁自定义类加载器的场景中一般要求垃圾回收器具备类型卸载的能力；
	虽然对象可能存在跨代引用的现象，严格分为新生代和老生代是无法实现的，但是这种现象较少出现，在MinorGC时，可以维持一个全局的数据结构-Rememberer Set, 用来标识老生代中那一块区域存在跨代引用，这样就会把相应老生代中的对象放入GC Roots中，而不是老生代中全部的对象。
	标记清除的缺点：效率不稳定，随着对象的数量增加效率降低，其次为内存的碎片化；
	标记复制算法，解决碎片化问题，但是如果1：1的化空间浪费严重，且如果每次存活对象较多复制开销也会很大。考虑到现实中大多对象的存活时间很多，基本不会超过一次GC, 所以经典的新生代收集器中都是用一个较大的Eden区和两个较小的Survivor区的布局，如Serial和Parnew.
	Eden和Survivor的大小比为8：1,当然如果存活对象超过Survivor大小（10%）,可以通过分配担保机制直接存入老生代；
	标记整理算法，存活对象朝内存空间一端移动，然后集中清理边界之外的内存，这种移动式的回收算法虽然避免了内存碎片的问题，但是同时移动以及更新对象引用的代价也很大，尤其在存活对象很多的情况下，且进行移动操作时不得不暂停程序的运行；
	标记整理的优点也很显著，由于没有内存碎片，相对于标记清除算法，大大方便内存分配。由于内存分配和访问相比GC频率更大，因此可以提高系统的吞吐量，比如关注吞吐量的Parallel Scavenge收集器就是基于标记整理算法的；
	CMS关注时延，主要使用标记清除算法，当然当碎片过多的时也会触发标记整理过程。
算法实现细节
	跟节点枚举需要暂停程序运行，但不需要全局搜索，虚拟机中维护一个OopMap（普通对象指针map）数据结构来：记录类加载存放地址、栈与寄存器中哪些位置是对象引用等信息。
	虚拟机在安全点位置生成OopMap,而不是每一条指令都去更新OopMap,否则代价极大安全点位置一般是程序长时间运行的位置比如循环指令。
	线程是采用主动式中断的方法在到达安全点时发生中断。具体来讲，当垃圾收集需要中断线程时，会先设置一个标志位，线程执行过程中会不断轮询该标志位，发现中断标志时就在离自己最近的安全点上挂起。
	为了解决不执行线程比如sleep或blocked线程的停顿问题，引入安全区域的概念，即某一段代码片段，其中引用关系不会发生改变。
	未解决跨代引用的问题，主要式实现了局部回收的垃圾收集器，引入了记忆集的数据结构，作用是记录非收集区域中指向收集区域的指针集合。实际上，虚拟机使用卡表来完成，卡表中每个元素对应非收集区域的一个内存块，称为卡页，如果卡页中存在跨代引用对象，则标记为dirty. 垃圾回收时会加入到根节点中。
	卡表元素维护需要借助写屏障技术，赋值的前后都会在写屏障的范围内，分为写前屏障和写后屏障。引用对象赋值时会产生一个唤醒的通知。
	三色标记：白色尚未访问过，如果可达性分析结束后仍未白色则回收。黑色，访问过，且该对象的所有引用都已经分析过了，不会被回收，灰色，访问过但是其引用未完全访问。
	三色标记存在的问题是：当灰色到白色的引用全部被删除且新增黑色到白色对象的引用，则该对象会被标为白色而被误删除。解决方法是：（1）增量更新，记录黑色指向白色的插入操作，并发标记之后重新扫描这些黑对象；（2）原始快照，记录灰色删除白色引用操作，并发标记之后重新扫描这些灰色节点。虚拟机中对引用关系的插入和删除的记录都是通过写屏障实现的。
垃圾收集器
	常见新生代收集器：Serial 、ParNew、Parallel Scavenge，常见老生代收集器：CMS、Serial Old、Parallel Old。
	常见配合使用：ParNew - > CMS 、Serial -> CMS、Serial -> Serial Old、Parallel Scavenge -> Parallel Old 等。
	Serial：新生代、单线程、暂停程序、额外占用内存少、复制算法、简单高效、hotspot 虚拟机运行在客户端模式下的默认新生代收集器，在新生代内存较小的场景下依然较好的效果。
	ParNew, 新生代、多线程、复制算法、目前只可以和CMS使用，曾经是官方推荐的服务端模式下的收集器方案，默认开启收集线程数与处理器核心数量相同，参数 –XX:+/-UserParNewGC，在CMS激活后（-XX:+ConcMarkSweepGC）默认的新生代收集器；
	Parallel Scavenge: 新生代、多线程、多线程，关注吞吐量（处理器用于运行代码的时间与处理器总消耗时间的比值即运行代码时间/（运行代码时间 + 垃圾回收时间）、提供参数精确控制吞吐量；
	Serial Old：老生代， 单线程、客户端模式下使用、标记整理算法；
	Parallel Old :老生代、多线程、与Parallel Scavenge配合使用，关注吞吐量或处理器资源稀缺的可以考虑这种组合；
	CMS: 老生代、多线程、大部分应用使用、关注服务响应速度、获取醉最短回收停顿时间为目标，标记清除算法；
	过程：（1）初始标记，GC Roots直接关联的对象，需要暂停程序运行；（2）并发标记，遍历，与用户线程并发运行；（3）重新标记、需要暂停程序运行，并发标记中新产生的引用记录；（4）并发清除，因为无需移动对象，所以可以并发运行；
	缺点：（1）对处理器资源敏感，当处理器核心数较小时可能会降低系统吞吐量，默认回收线程数 = （核心数 + 3 ）/4；（2）并发中产生的浮动垃圾； （3）内存碎片问题，提供参数可以在不得不Full GC 时开启整理过程。
	JDK 9 之后， CMS已经不被推荐使用，
	G1 :多线程、全堆、全功能服务、面向服务端的垃圾收集器，局部收集、基于Region的内存布局， 可预测的停顿模型！！
	堆分成连续的大小相等的Region, 而没有物理上的划代分区。但是对于每一个Region 可以根据需要划分为eden 和 survivor 或老生代空间，来执行不同的回收策略.Region 是垃圾回收的最小单位，收集器跟踪每个Region的回收价值并在后台维护一个回收的优先列表，优先回收价值高的，至于回收多少则根据用户设定的允许收集停顿时间（-XX:MaxGCPauseMillis）默认是两百毫秒
	G1的收集效率较高；
	Region 内存布局同样需要考虑跨Region引用的问题，解决的方法和CMS类似，每个Region均维护一个记忆集，本质上是一个哈希表，以Region起始地址为键，卡表集合为值，由于维护的数据机构很多，占用较多的内存（10-20%的堆内存）是一个问题。
	过程：（1）初始标记（2）并发标记（3）最终标记（4）筛选回收，该过程同样需要暂停程序运行，启动并发的收集线程，这是因为Region中存活对象移动到空闲Region以及原来Region的回收均设计移动对象的操作。不过因为只移动一部分对象，停顿时间是可以接受的，并且可以保证吞吐量。
	G1以及之后的收集器开始不追求在每次垃圾回收时进行全局回收，而是只要满足应用内存分配速度和垃圾回收速度匹配即可；
	G1的缺点时占用额外内存、以及维护卡表的相应开销更大（除了卡表维护的写后屏障，还有实现快照搜索算法中使用写前屏障来跟踪并发时的指针变化。）
	一般来讲对于内存占用较小的使用CMS在性能上完全可以优于G1,一般认为6G-8G是一个分界点。
	Shanandoah 和 ZGC 收集器均朝向更小的延迟为目标发展，两者类似，不过前者只在OpenJDK中可以使用。
	Shanandoah可以将垃圾回收时间限制在十几毫秒以内，其内存布局基本和G1类似，不过不对region 进行分代，也不再使用占据内存和计算资源的记忆集来维护跨区引用，而是使用连接矩阵来实现，占用内存更少
	Shanandoah的回收过程：初始标记、并发标记、最终标记、并发回收、并发引用更新、并发清理。在并发回收时利用读屏障和转发指针来实现安全的更新对象指针。整个回收过程中机会都是并发的，不过由于对象访问概率比写要大很多，相应的读屏障过多会带来性能的下降是一个重要问题。
	测试证明其吞吐率降低较明显，这是一个权衡。吞吐率、占用内存、时延无法同时满足。
	ZGC的目标是对于任何堆的垃圾回收要求停顿时间少于10毫秒，且保证吞吐率不会产生太大影响。ZGC和Azul System公司的C4收集器极为相似；
	ZGC基于Region的堆内存布局，并且Region大小具有动态性（大中小）并且可以动态创建或销毁，使用了读屏障、染色指针、以及内存多重映射等技术实现并发的标记整理算法，以低延迟为首要目标。
	小Region 2M, 存放对象小于256KB的对象，中Region32MB， 存放小于4MB的对象，大Region存放4MB以上的对象，容量不固定。
	染色指针：通过对象头上的信息来标记对象不仅需要考虑并发问题，实际上标记本质上和对象无关仅和引用相关，另外使用数据结构存储又占据过多的内存如G1的bitmap, 染色指针标记引用指针，之所以指针可以存储额外信息是因为在64位操作系统中，AMD64架构中往往只会用到52位的地址总线和48位的虚拟地址空间，实际上目前windos操作系统中只会用到44位、linux支持46位（64T）足以满足需求。
	用于标记的仅仅是高4位，可以标记信息包括三色标记状态、是否进入重分配集、是否只能通过finalize()访问等信息
	染色指针的优势：减少收集过程中内存屏障的使用，ZGC中目前仅使用了读屏障。
	为了使得操作系统支持这种机制，ZGC使用了多重映射将多个虚拟内存地址映射到同一个物理内存地址上，使得染色指针可以正常进行寻址
	回收过程：(1)并发标记，指针上标记；（2）并发预备重分配，扫描所有Region,将本次需要回收的Region组成重分配集（Relocation set）；（3）并发重分配，给每个重分配集中的region维护一个转发表，记录旧对象到新对象的转换关系，用户访问位于重分配集中的对象，会被内存屏障截获，将根据该表转发访问同时更新引用（指针自愈），所以只会慢一次。一个region中的对象全部复制完毕后，该Region立刻可以用于新的对象分配。（4）并发重映射，即修正全堆指向重分配集中旧对象的引用，这一步不会特意去做，而是在并发标记是顺便执行，同时删除转发表。
	ZGC的优点：由于没有使用记忆集，以及维护记忆集的写屏障，占用内存少且执行效率提升。
	缺点：由于暂时没分代，可能会导致无法承受较高的内存分配速率，直接表现就是每次清除的对象和产生的浮动垃圾相比较小，全堆扫描，并发过程较长，相应的浮动垃圾也多，无法及时回收。
GC日志
	常见指令JDK9之前：
-XX:+PrintGC， 输出简要GC日志
-verbose:gc， JDK8中和PrintGC一样格式，后者已经不推荐。
-XX:+PrintGCDetails， 输出详细GC日志
-Xloggc:gc.log  输出GC日志到文件
-XX:+PrintGCTimeStamps 输出GC的时间戳（以JVM启动到当期的总时长的时间戳形式）
-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）
-XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息

-XX:+PrintReferenceGC 打印年轻代各个引用的数量以及时长
-XX:+PrintGCApplicationConcurrentTime, 用户线程并发时间
-XX:+PrintGCApplicationStoppedTime，用户线程停顿时间
-XX:+PrintTenuringDistribution, 收集后存活对象的年龄分布信息
	JDK9之后：
JDK9之后的虚拟机日志统一归到参数：-Xlog中，后面接不通参数可以显示不同日志，垃圾回收为gc
-Xlog:gc , 打印日志
-Xlog:gc*, 打印详细日志
-Xlog:gc+heap=debug, 打印GC前后堆容量变化
-Xlog:safepoint, 打印用户线程并发和停顿时间
-Xlog:gc+age=trace, 打印存活对象的年龄分布信息
	常用垃圾收集器虚拟机参数：
UseSerialGC， Serial + Serial Old
UseParNewGC,  ParNew + Srerial Old ， jdk9后不支持
UseConcMarkSweepGC,  Parnew + CMS + SerialOld， 9后不支持
SurvivorRatio, 默认为8
UseG1GC, jdk9后的默认服务器使用
PretenureSizeThreshold, 大于指定值的对象直接存入老生代（只对Serial、ParNew两个新生代有效）
MaxTenuringThreshold, 晋升老生代的年龄限制，默认15
内存分配与回收策略
对象有限存储edan中
大对象一般直接存入老生代，可以设置大小限制
长期存活的对象进入老生代
当survivor中相同年龄对象的和超过一般大小时，这些对象直接进入老生代，并不完全按照年龄
Minorgc 时如果survivor无法存下所有存活对象，通过空间分配担保直接进入老生代
虚拟机进程状况基础工具
	jps，查看虚拟机进程的本地虚拟机lvmid和主类
	注意，对于本地虚拟机，LVMID与进程id一致。
	参数-l, 显示主类全名。
	-v, 启动时jvm的参数，比较有用。
	-m, 显示传递给主类的参数。
虚拟机统计信息监视基础工具
	jstat, 显示虚拟机集成中的类加载、内存、GC、JIT等运行数据。
	可选的选项包括：-gc 、-class、-gcnew、-gcold、-gccapacity、-gcutil(重点输出已使用空间占比)、-gccause(重点出书GC原因)、-compiler(JIT编译过的方法)、-printCompilation(打印JIT的方法)等。
	使用方法：jstat + 选项 + JVMID + Intervals + count , 其中interval表示每隔多少毫秒更新一次，count为显示次数。
虚拟机配置信息查询和修改（部分参数支持）基础工具
	jinfo， jps –v仅可以查看显示指定的虚拟机参数，该工具可以查看默认参数。
	jinfo –flags pid, 查看默认参数。
	jinfo –flag +|- name pid , 修改参数。
Java内存映像基础工具
	Jmap,可以生成堆转储快照文件、查看堆与方法区使用信息、finalizer执行队列等详细信息。
	也可以通过JVM参数 –XX:+HeapDumpOnOutOfMemoryError在出现OOM时生成堆转储快照
	-dump, 生成堆转储快照（如.bin）， jmap –dump:file=filename pid
	-heap, 显示堆详细信息包括GC收集器、分代状况等等
	-finalizerinfo, 显示F-Queue中点灯执行finalize的方法
	-F, 强制生成dump文件
堆转储快照文件分析基础工具
	jhat, 分析jmap生成的dump文件, 查看类加载器、类、引用等内存信息。 提供浏览器访问模式， 不过并不好用,相对于其他可视化工具而言。
Java堆栈跟踪基础工具
	jstack , 生成所有线程包括c1 、c2、gc等用户线程的快照信息。可以查看线程的状态和栈内容，通常用于定位线程长时间停顿的原因（死锁、请求外部资源等）
	选项：-l ,显示堆栈信息，以及关于锁的附加信息
	-F, 强制输出
	-m, 显示调用的本地方法栈（c++/c）
	当然Java的Thread类中也提供了一个getAllStackTrace（）方法来获得这类信息，可以达到类似功能。
VisualVM
	可视化监测和故障处理工具，免费、通用性强，集成了JDK命令行工具以及具备一定的基础的分析能力。
	可以：现实虚拟机进程状态以及环境信息，监视线程信息、监视处理器状态、内存状体、堆栈方法区情况、GC情况，生成和分析堆转储快照，分析调用情况方法等；
	更多功能可以通过下载插件实现；

类加载机制
类加载过程概述
	Class文件加载到内存，经过数据校验、转换解析和初始化、最终形成虚拟机直接使用的Java类型；
	Java编译时无需连接步骤，运行期的动态加载以及动态连接时Java动态语言特性的一个重要特性。
类加载时机
	加载时间和具体JVM有关，一般来讲当遇到new 实例化对象、设置或读取类型静态字段的（非final）、反射调用时遇到未初始化类型、父类没有初始化的、执行主类的初始等场景会进行类的初始化。
类加载过程-加载
	完成事情：依据类的全限定名来获取类的二进制流，将静态存储结构转化为运行时数据结构，并创建相应Class对象，作为数据访问入口
	加载可以使用内置的引导加载器完成，也可以自定义加载器，可以控制字节流的获取方式（重写类加载器的findCLass（）、loadClass()等方法。
	数组类并不是通过类加载加载的，而是直接由虚拟机在内存上构造，不过还是会标识在指定类加载器的类名称空间上。如果元素时基本数据类型则时引导类加载器，如果引用类型则是相应类型的加载器。
类加载过程-验证
	为什么要验证，因为字节码Class文件不一定要求是Java源码编译而来可以是认为编辑等任意途径，为了防止恶意代码攻击系统，必须惊醒class文件格式合法性的验证；
	文件格式验证：是否符合class文件格式；
	元数据验证：字节码描述信息的语义分析，比如是否类有父类，是否继承了final类、是否实现父类所有方法，是否存在和父类矛盾的方法等；
	字节码验证：最复杂， 是程序代码的语义分析，比如是否存在错误的类型转换指令、跳转指令是否正常等，当然这一步不是检查bug的，程序已久可能存在问题；
	符号引用验证：
类加载过程-准备
	完成任务：类静态变量分配内存（方法区，也是堆上），并赋予零值；
	除了少数在字段属性表中存在ConstantValue属性的字段会在准备阶段就赋予初始值外，其它均是零值；真正的赋值操作指令putstatic 将在类构造器的<clinit>（）方法中调用。
类加载过程-解析
	解析是将常量池内的符号引用转化为直接引用，解析的时机没有明确规定，一般是在调用到相应的操作符号引用指令前完成。直接引用何实际内存地址相关。
	解析主要针对：类与接口、字段、类或接口方法等；
类加载过程-初始化
	初始化类变量，真正开始执行代码，通过收集类中的类变量赋值操作、静态代码块中的语句合并生成<clinit>（）方法并执行的过程，当然如果没有变量赋值或静态代码块则也可以不生成该方法。
	与实例构造器<init>（）差别在于，后者会显示调用父类的构造器，而类加载中，虚拟机会保证在执行该类的<clinit>()方法前先执行父类的构造器。
类加载器
	类加载器独立于jvm, 最早是为了满足Java applet的需求设计的；
	对于一个类来讲类与其类加载器共同确定其在Java虚拟机中的唯一性，每一个类加载器都具有其独立的类名称空间。
	类相等的前提必须是由同一个类类加载器加载；
	类加载器从虚拟机的角度上可以分成两类：启动类加载器，虚拟机的一部分，c++编写； 其它类加载器， Java编写，继承于Java。Lang.ClassLoader独立于虚拟机外。
	一般具体可以三层类加载器
	启动类加载器，<JAVA_HOME>/lib目录下的类或  -Xbootclasspath指定的路径,开发人员不能直接访问,不过可以通过ClassLoader的getClassLoader()方法中使用null来委派其处理.
	类扩展加载器:<JAVA_HOME>/lib/ext中的类;
	应用类加载器, 加载用户路径classpath上的类,是应用程序默认的.
双亲委派模型
	一个类加载器收到类加载请求后, 首先将其交给父加载器进行处理,直至到启动类加载器,如果父加载器无法处理(在自己的搜索范围内未找到该类)才交给子加载器去处理
	好处是使得通过一个类无论通过什么加载器加载最终都会由同一个类加载器加载,避免类型混乱保证程序的稳定,类随着加载器具有了优先级的层次关系;
	双亲委派是在loadClass()方法中实现的,但是不是强制的.
编译与优化
编译的基本概念
	Java中的编译可能在不同语境下指的不同场景，包括：（1）前端编译：Java原代码转变成字节码文件；（2）字节码变成本地机器码虚拟机的即时编译JIT；（3）静态的提前编译器直接将原代码转化成与目标机器指令集相关的二进制代码；
	三类编译中以第一类为主；
	各自的场代表包括：Javac 、C1与C2、Jaotc；
前端编译
	Javac是Java语言编写的；
	编译过程：（1）初始化插入式注解处理器；（2）语法分析，构造抽象语法数；（3）填充符号表，产生符号地址信息；（4）有插入式注解处理器主导的注解处理过程；（5）语义分析，检查标注、数据流、控制流、解析语法糖，然后生成字节码文件
	注解处理器可以实现许多原本只能在代码中完成的工作，可以帮助开发人员简化冗余代码，比如lomboc就是通过注解来实现的。
	语法糖是计算机语言中的某类语法，对于编译结果没有影响，但可以减少代码增加程序的可读性，常见的Java语法糖包括：泛型、变长参数、自动拆箱装箱、内部类、枚举类、遍历循环、以及lambda等。
	泛型：参数化类型，抽象的参数类型可以用在类、接口或方法的创建中，Java泛型是类型擦除式泛型，C#则是具现化式泛型，字节码文件中泛型会全部替换为原来的裸类型（Row type ,泛型化子类的共同父类型），然后在代码中插入一些强制类型转换的语句（比如Object to String等）。这实际上产生了较多的问题，较多的封箱开箱操作以及不符合面向对象的设计思想
	条件编译。也是一个简单的语法糖，是对常量条件的代码进行消除相当于预处理。
后端编译
	JIT和提前编译两者均不是Java虚拟机的必须组成，但是确实商业虚拟机性能评价的重点；
	为什么要使用解释器 + 编译器并存的架构：解释器作为程序的主要执行者而存在，首先可以减少内存，其次在程序运行初期省去编译时间，尽快提供服务，当程序运行长时间后，有些热点方法或代码频繁执行，使用编译器变异成本地机器码可以提高执行效率；
	当程序发生变化时相应的回退到解释器状态执行称为逆优化；
	HotSpot中主要包括两个即时编译器：客户端编译器和服务端编译器，C1 、C2; jdk9之后的Graal编译器旨在代替C2尚在实验
	用户可以通过参数-client 或 –server来指定选择；
	用户也可以使用-Xint或-Xcomp来选择只使用解释器或优先编译器，默认是混合模式
	编译器编译本地代码需要占用运行时间，并且编译中改进行优化需要采集性能监控信息，对解释执行的速度产生影响；
	分层编译是为了在虚拟机启动响应速度和执行效率之间达到最佳平衡提出的：第0层：纯解释执行，且不开启性能监控；第1层，C1运行，不开启性能监控，只进行简单的优化；第2层，C1编译， 开启有限的性能监控如统计方法；第3层， C1编译器，开启全部性能检测；第4层， C2 , 启用多的优化，编译时间更长；
	简单来将，C1编译速度更快，C2编译质量更好；
	编译的热点代码指的是方法和循环体，当然编译时还是以方法为单位的，其中对调用频繁方法的编译时虚拟机JIT的标准编译，而又循环体触发的编译又称为栈上替换（OSR）,发生在方法的运行过程中；
	编译是有后台的编译线程完成的，编译完成之前依旧通过解释器执行；
	编译的触发有两种方式：基于采样的热点探测，简单但是不精确；基于技术的热点探测，包括方法调用计数器和回边计数器（边界），精确但是复杂
	C2中的执行大多数的优化动作，包括：方法内联、无用代码消除、循环展开、循环表达式外提、消除公共子表达式、常量传播等；
	由于jit占据程序运行时间，所有提出了提前编译，虽然和Java的设计之初提的口号一次编译处处运行相违背，但是近年来也得到很大重视；

并发-内存模型与线程
内存模型
	并发是提升效率的必然选择
	从硬件角度上看，cache缓解处理器与内存速度差异，多个处理器各自维护的cache因为共享内存则会存在不一致问题，另外为了充分利用处理器内的计算单元代码可能会乱序执行，对应JIT中的指令重排序；
	Java内存模型作用：内存访问过程的抽象，为了屏蔽各种硬件和OS内存访问差异， 主要定义了各种变量（对象实例字段、类静态字段、数组元素等，不包括局部变量和方法，后者是线程私有的）；
	内存模型为：主内存 + 工作内存， 所有变量均存储与主内存中，每个线程具有自己的工作内存保留变量副本，线程只在工作内存中对数据进行操作，然后将这些操作传递给主内存，注意volatile修饰的变量依然保有工作内存副本。
	主内存可以近似看成是堆中的对象实例数据中，工作内存则位于栈中的某些位置，或者从硬件上将，更可能是主内存位于内存，工作内存位于寄存器或cache中，但是上述不是完全等同的概念。
	-XX：+PrintAssembly 打印反汇编结果;
	Java内存模型中定义的8种不可再分的原子操作包括：
（1）	lock , 作用于主内存变量， 变量被一个线程独占；
（2）	unlock，作用于主内存变量， 释放锁使可被其他线程锁定；
（3）	read，作用于主内存变量，将变量值传输到线程工作内存中；
（4）	load，作用于工作内存变量，更新到线程工作内存副本中，read后续操作，两者必须按顺序进行（不是一定要连续），不能单独出现；
（5）	use，作用于工作内存的变量，将变量值传递给执行引擎；
（6）	assign, 作用于工作内存变量， 从执行引擎接受到的值赋值给工作内存变量；
（7）	store，作用于工作内存变量，将变量传给主内存；
（8）	write，作用于主内存变量，写入主内存，store后续操作，两者顺序执行，不可单独执行；
	注意：对于double 和long类型的数据，在某些平台上可能对应load、store、read、write等操作不是原子性的；
	相应操作的限制条件或协议：
（1）	read 与 load 以及store与write必须成对执行；
（2）	assign 后必须写会主内存，没有assign不可以写回；
（3）	lock只可以被一个线程执行，但是可重入；
（4）	lock与unlock顺序执行；
（5）	变量unlock之前，必须先写回；
	Volatile作为一种轻量级同步机制，修饰的变量具有两个特性：
（1）	变量对所有线程可见性，某线程对变量的修改，该修改会被其他线程立刻得知（其他线程每次使用过都会刷新所以不存在不一致情况）。但是依然在并发情况下可能出现不一致，在变量的某些非原子操作中，如果期间其他线程修改了数值，操作栈中依然是旧值。
（2）	禁止指令重排序的优化，具体是通过插入内存屏障（后面指令不会排序到内存屏障之前，将修改同步到内存）
	总体来讲，volatile的性能要优于锁，读和普通变量相近，写稍慢；
	内存中模型中针对volatileti提出的特殊规则：
（1）	Read 、load、use必须顺序连续执行，使用前必更新；
（2）	Assign、store、write必须顺序连续执行，修改后必写回；
（3）	哪个变量先use或assign, 那个变量必然先read或write,该规则保证了不会指令重排序；
	并发过程中的三个重要特性分析：
（1）	原子性：一般认为对基本数据类型变量的访问、读写都是原子性的，对于更多操作则需要使用synchronized等锁来保证原子性，底层对应monitorenter 与monitorexit字节码指令；
（2）	可见性：除了volatile, synchronized 以及final也可以实现可见性；
（3）	有序性：本线程内操作有序，其他线程操作无序，synchronized以及volatile可以保证有序性；
	先行发生原则：用来更快速简单的判是否存在数据竞争需要引入同步，所谓的先行关系就是两项操作之间存在影响，满足先行发生原则的这些操作，本身就存在同步含义，不需要额外的同步机制，也不会进行指令重排序，常见的包括：
（1）	程序次序规则；
（2）	管程锁定规则，unlock 在lock后；
（3）	Volatile变量规则：变量写后读
（4）	线程启动规则：start()先于线程方法；
（5）	线程终止规则：线程操作先于终止探测；
（6）	线程中断规则：
（7）	对象终结规则：对象初始化先于finalize()
线程
	引入线程：资源调度与执行调度分开；
	Java Thread类中关键方法都被声明为Native, 意味着平台相关的手段实现；
	线程实现有三种：
（1）内核线程，OS内核（支持多线程）完成线程的切换与调度，并向应用程序提供高级接口-轻量级进程（LWP）即线程，每一个内核线程都和一个LWP一一对应。优点是线程的管理工作主要有内核负责，程序设计简单。缺点是线程调度产生的系统调用代价较高，内核态与用户态的不断切换消耗内核资源，同时系统支持的线程数量也有限；
（2）用户线程，内核看不到线程，线程的建立、同步、销毁以及调度均在用户态中完成，优点是调度快速高效，且支持创建线程数量更多，缺点是程序复杂；
（3）混合式线程
	Java中的线程是内核线程，基于操作系统原生的线程模型实现，每一个Java线程都直接映射到OS的一个原生线程；
	线程调度方式主要有两种：
（1）	协同式线程调度：实现简单，线程执行完任务后通知系统切换线程，但是线程执行时间不可知，线程如果出现阻塞可能会导致系统崩溃；
（2）	抢占式线程调度，系统统一分配时间，整体线程执行时间可控，Java中采用这种方式，为更好的利用系统，可以通过设置线程的优先级来优化线程的时间分配；
	线程状态装换：
（1）	新建：New, 创建尚未启动，start()触发；
（2）	运行：Runnable, 包括操作系统线程状态中的Running与ready, 在该状态下，线程可能正在运行或等待系统分配时间；
（3）	无限期等待：waiting， 线程不会被分配执行时间，需要等待显示唤醒，wait(),join()等方法触发，notify()等方法改变；
（4）	有限期等待：Timed waiting， 等待指定时间，然后自动唤醒，如wait(timeout)、join(timeout)、sleep()等方法触发；
（5）	阻塞：bolcked, 线程不分配时间，等待锁，线程进入同步区域时触发，比如synchronized;
（6）	结束：terminated， 线程结束执行，run()方法执行完毕时触发；
	内核线程切换调度成本高，容纳的线程数量有限，并且线程数越多这部分开销的占比就越大，会对系统性能产生较大影响。所谓用户态和内核态的状态切换产生的开销，主要是响应中断、保护和恢复执行现场，保护上下文中设计寄存器和缓存的来回拷贝。
	因此用户线程一般也成为协程，又重新进入视线，Java在2018年创建的Loom项目中重新提供对用户线程的支持，目前正在实验中
线程安全
	线程安全的严格定义：多个线程访问一个对象时，如果不用考虑线程在运行环境下的调度和交替执行，也不需要额外的同步，或在调用方法进行任何其它的协调操作，调用这个对象的行为均可以获得正确的结果。
	Java 中保证对象行为不影响自己状态简单的方法是将变量申明为final, 对象构造或赋值完成后及不可改变；
	线程安全的实现方法：
（1）	互斥同步（阻塞同步）：悲观策略，synchronized、reentrantlock、信号量、互斥量等；
（2）	非阻塞同步：乐观策略，基于冲突检测，CAS;
（3）	无同步方案：可重入代码或线程本地存储ThreadLocal;
	Synchronized, 编译后会在同步快前后插入monitorenter和monitorexit字节码指令，指令需要一个引用类型的参数指定加锁和解锁的对象。如果当前线程已经持有锁，则计数器加一，所以是可重入的；
	相比如synchronized， 基于类库Lock接口的ReentrantLock，以非块结构的方式实现同步，扩展性更好，在前者基础上增加了特性：
（1）	等待可中断；
（2）	可以通过带有布尔参数的构造函数改成公平锁，不过这样会降低吞吐量；
（3）	一个锁可以绑定关联多个condition；
	两者性能基本差不多，总体来讲，synchronized使用简单，不需要关心锁的释放不会出现死锁，而Lock需要手动释放；且JVM针对synchronized进行优化更加容易，因为对象元数据以及线程中有相关锁的信息；
	无锁编程，采用乐观并发策略，如果没有数据竞争则直接操作，否则不断重试，并不需要挂起线程，前提是操作以及冲突检测是原子性的，所以依赖于硬件的指令集，Java中主要使用的是CAS指令；
	CAS指令包括三个参数：内存地址、旧值（预期值）、待修改的新值，如果数据不等于旧值则有冲突则重复执行，指令结束返回的是旧值。Java9之后可以通过反色来使用Unsafe类了；
	例如：AtomicInteger 整数原子类中的getAndIncrement()等方法中就用到了CAS;
	CAS存在ABA问题，可以通过控制变量值的版本来保证，但是鉴于ABA问题本身几乎不会对正确性产生影响，相应的改进反而降低效率不如同步来的快了。
锁优化
	锁优化技术是为了提高并发处理效率，提升程序执行效率；
	主要包括：自旋锁、自适应自旋、锁消除、锁粗化、轻量级锁、偏向锁、锁膨胀等；
	自旋锁：对象被其他线程加锁，本线程不阻塞而是空转占用处理器时间，默认开启，默认次数10次，可以通过-XX:PreBlockSpin来更改;
	自适应自旋， 进一步优化，自旋时间不固定，而是依据线程之前取该对象锁的情况就决定，如果取锁失败比较困难则自旋时间短或不自旋。随着程序运行时间变长以及监控信息的完善，可以做到更智能；
	锁消除，有时候很多同步措施不是程序员自己加入的，而是由于使用的对象默认开启的，而即时编译可以对这一类没有必要的锁进行识别，进而消除；
	锁粗化：如果在程序的某些代码中同步快出现频繁，甚至是循环体中，与其频繁进行进行锁的切换，还不如更大范围加锁；
	轻量级锁：所谓轻量级相对于传统OS互斥量等重型锁，是在线程竞争较少的情景下用来减少重量锁带来的性能降低；
	实现依赖于对象头的mark word（运行时数据），在32 和64位机器上分别占据32bit和64bit, 以32为例，未锁定时的字段含义：25bit存储hashcode, 4bit存储GC分代，， 1bit表示偏向模型（0表示未进入偏向模式），2bit存储锁标志位（01）。
除了未锁定， 此外还有状态：
（1）	轻量级锁：2bit标志位（00），其余30bit存储指向调用栈中锁记录的指针；
（2）	重量级锁：2bit标志位（10），其余30bit存储指向重量级锁的指针；
（3）	GC标记：2bit标志位（11），其余为空；
（4）	可偏向：2bit标志位（01），1bit表示偏向模式（1），其余存储线程id,分代年龄等信息。
	轻量级锁工作过程：线程将要进入同步区，如果对象未被锁定，首先通过CAS将当前markword复制到其栈帧中称为锁记录，然后将mark word中的内容替换为指向锁记录的指针，即为获得偏向锁。释放是则将栈帧中的锁记录复制回markword, 同样基CAS, 如果中间有其他线程请求过则释放同时唤醒该线程。在线程保有锁期间，有超过两个线程请求锁，则膨胀为重量锁，markword中的记录也更新为对应互斥量的指针。
	偏向锁，连CAS都不要了， 在无竞争的情况下，锁偏向于第一个获得他的线程。线程进入偏向模式后，将线程的id等信息记录在markword中（这里还是有CAS的），以后该线程进入什么也不用做直接访问，而一旦其他线程请求则该模式立刻结束，进入偏向锁（还在占用）或为锁定状态（没有线程占用）；



