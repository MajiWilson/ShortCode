

集群主从复制：    为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型
数据分片：       哈希槽， hash slot, Redis 集群有16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽
数据一致性：     Redis 并不能保证数据的强一致性. 这意味这在实际中集群在特定的条件下可能会丢失写操作， 因为主从复制是异步的， 且会因为网络分区等原因触发从被选主
集群部署配置：     port 7000
                cluster-enabled yes
                cluster-config-file nodes.conf
                cluster-node-timeout 5000
                appendonly yes

Java 客户端： Jedis


分布式锁：需要满足的基本要求（1）安全属性，独享：任何时刻只有一个客户端持有锁；（2）无死锁，当因为客户端崩溃或者网络分裂， 锁还能被其他客户端获取到 （3）可用性，容错， 只要大部分节点存活就能够正常获取和释放锁；
        实现Redis分布式锁的最简单的方法就是在Redis中创建一个key，这个key有一个失效时间（TTL)，以保证锁最终会被自动释放掉（这个对应特性2）。当客户端释放资源(解锁）的时候，会删除掉这个key。但是上面存在一个问题：
        单点失败：A 获取锁后， master还没有复制到salve（异步）， 这个时候master挂了， salve被选为主， 则B也可以获取同一个锁， 导致安全失效！

        单实例锁：SET resource_name my_random_value NX PX 30000， eval方法释放（luna脚本解释执行, 三个参数， 脚本， key数量， keys）， 不同客户端给Key赋值不同， 释放的时候会比较value不会误释放其他客户端正在占用的锁； 脚本例子
                		if redis.call("get", KEYS[1]) == ARGV[1] then
                			return redis.call("del", KEYS[1])
                		else
                			return 0
                		end`
        多实例算法：（ReadLock): 假设有N个Redis master。这些节点完全互相独立，不存在主从复制或者其他集群协调机制, 为了取到锁，客户端应该执行以下操作:
            获取当前Unix时间，以毫秒为单位。
            依次尝试从N个实例，使用相同的key和随机值获取锁。在步骤2，当向Redis设置锁时,客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个Redis实例。
            客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。当且仅当从大多数（这里是3个节点）的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。
            如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。
            如果因为某些原因，获取锁失败（没有在至少N/2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功）。
            ** 理想情况下， 一个客户端应该同时向所有实例发送Set命令，如果获取失败了应该在一个随机延迟后重试,防止多个客户端在同时抢夺同一资源的锁（这样会导致脑裂）
            ** 异常情况下， 一个已经获取锁的节点重启，如果没有备份，可能会导致其他客户端也能获取锁， 理论上为保证锁的安全性，应该fsync=always，开启备份， 另外重启后的节点暂时不参与锁获取（不可用）也可以达到目的。即所谓延迟重启。

回收策略：
    当maxmemory限制达到的时候Redis会使用的行为由 Redis的maxmemory-policy配置指令来进行配置。以下的策略是可用的:
    noeviction:         返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）
    allkeys-lru:        尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。
    volatile-lru:       尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。
    allkeys-random:     回收随机的键使得新添加的数据有空间存放。
    volatile-random:    回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。
    volatile-ttl:       回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。
    * 可以在运行时进行相关的策略调整，并且监控缓存命中率和没命中的次数，通过RedisINFO命令输出以便调优。

    redis中的LRU不是真正意义上的， 没办法选择最佳候选来进行回收（消耗太大的内存和CPU时间)，也就是最久未被访问的键。相反它会尝试运行一个近似LRU的算法，通过对少量keys进行取样，然后回收其中一个最好的key（被访问时间较早的）， 这个取样的效果在数据近似为幂定律的访问模式的时候， 没有很大差别
    这个样本数量可以通过指令指定：maxmemory-samples 5

数据到期删除：
    Redis keys过期有两种方式：被动和主动方式。
    当一些客户端尝试访问它时，key会被发现并主动的过期。
    当然，这样是不够的，因为有些过期的keys，永远不会访问他们。 无论如何，这些keys应该过期，所以定时随机测试设置keys的过期时间。所有这些过期的keys将会从密钥空间删除。
    具体就是Redis每秒10次做的事情：
    测试随机的20个keys进行相关过期检测。
    删除所有已经过期的keys。
    如果有多于25%的keys过期，重复步奏1.

    **超时后只有对key执行DEL命令或者SET命令或者GETSET时才会清除。 这意味着，从概念上讲所有改变key的值的操作都会使他清除

管道：
    Redis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务
    一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。这就是管道（pipelining）
    管道的作用是：减少客户端和服务端之间交互的耗时，不过这依赖服务端维护一个返回队列， 相应会占据内存
    当然大部分 pipeline 应用场景可通过 Redis 脚本（Redis 版本 >= 2.6）得到更高效的处理


发布订阅：






