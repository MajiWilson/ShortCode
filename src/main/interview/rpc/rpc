RPC :
    基本概念： 远程过程调用协议
    简单理解：一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议
    常见实现：Dubbo、Thrift、GRPC、Hetty、SpringCloud
    解决问题：服务化 、微服务和分布式系统架构的场景下的系统高效交互, 且可以让使用者不感知网络通信细节和跨语言

RPC框架需要解决的三个主要问题：
    （1）如何确定远程调用哪个函数？
        本地调用中可以通过指针来调用函数，但是远程调用中缺乏这种映射关系
        在RPC中，所有的函数都必须有自己的一个ID， 需要在客户端和服务端分别维护一个 {函数 <--> Call ID} 的对应表。两者的表不一定需要完全相同，但相同的函数对应的Call ID必须相同。
        然后请求调用的时候需要带上这个ID信息

    （2）如何将函数参数传给远程函数？
        在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。
        但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言（比如服务端用C++，客户端用Java或者Python）。
        这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。

        序列化：将对象专成二进制流， 发序列化反之


    （3）选择什么网络协议进行数据传输？
        网络传输层需要把Call ID和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。
        对网络协议是不限制的一般使用TCP协议，但其实UDP也可以，而gRPC干脆就用了HTTP2

RPC框架的核心组件：
    （1） 客户端（Client）：服务的调用方。
    （2） 服务端（Server）：服务提供者。
    （3） 客户端存根（Client Stub) ：存放服务端的地址消息，将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。
    （4） 服务端存根 (Server Stub）：接收客户端发送过来的消息，将消息解包，并调用本地的方法。

    除了核心的序列化组件和网络传输组件，此外还包括：服务发现（服务暴露），负载均衡（服务端选择一个实例来处理请求）、异步调用等支撑功能

RPC 过程：
    1. 服务消费方（client）以本地调用方式调用服务；
    2. client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；找到服务地址，并将消息发送到服务端；（client stub封装、发送）
    3. server stub收到消息后进行解码，根据解码结果调用本地的服务；本地服务执行并将结果返回给server stub；server stub将返回结果打包成消息并发送至消费方。（server stub解码、调用、返回与发送）
    4. client stub接收到消息，并进行解码。服务消费方接收返回结果；

RPC & HTTP: 其实不是一个层次的东西
    （1）传输效率：
    • TCP：通常自定义上层协议，可以让请求报文体积更小
    • HTTP：如果是基于HTTP 1.1 的协议，请求中会包含很多无用的内容
    （2）性能消耗，主要在于序列化和反序列化的耗时
    • TCP，可以基于各种序列化框架进行，效率比较高
    • HTTP，大部分是通过 json 来实现的，字节大小和序列化耗时都要更消耗性能
    （3）跨平台：
    • TCP：通常要求客户端和服务器为统一平台
    • HTTP：可以在各种异构系统上运行
    总结：
    • RPC 的 TCP 方式主要用于公司内部的服务调用，性能消耗低，传输效率高。
    • HTTP主要用于对外的「异构环境」，浏览器接口调用，APP接口调用，第三方接口调用等。


Dubbo: alibaba 开源：
    一句话：
        Dubbo 在微服务应用开发框架之上抽象了一套 RPC 服务定义、暴露、调用与治理的编程范式
    包含的内容：
        （1）RPC 服务定义、开发范式。
            比如 Dubbo 支持通过 IDL 定义服务，也支持编程语言特有的服务开发定义方式，如通过 Java Interface 定义服务。
        （2）RPC 服务发布与调用 API。
            Dubbo 支持同步、异步、Reactive Streaming 等服务调用编程模式，还支持请求上下文 API、设置超时时间等。
        （3） 服务治理策略、流程与适配方式等。作为服务框架数据面，
            Dubbo 定义了服务地址发现、负载均衡策略、基于规则的流量路由、Metrics 指标采集等服务治理抽象，并适配到特定的产品实现。

    Dubbo 对通信协议的支持具有以下特点：
        （1）不绑定通信协议
        （2）提供高性能通信协议实现
        （3）支持流式通信模型
        （4）不绑定序列化协议
        （5）支持单个服务的多协议暴露
        （6）支持单端口多协议发布
        （7）支持一个应用内多个服务使用不同通信协议


    基本架构： 两个抽象模块
        （1）服务治理抽象控制面 ：
            注册中心
            服务发现 ： 默认提供 Nacos、Zookeeper、Consul 等多种注册中心适配，与 Spring Cloud、Kubernetes Service 模型打通，支持自定义扩展。
            流量管控策略
                负载均衡：默认提供加权随机、加权轮询（会存在处理满的机器累积的情况）、最少活跃请求数优先、最短响应时间优先、一致性哈希和自适应负载等策略
                流量路由： 支持通过一系列流量规则控制服务调用的流量分布与行为，基于这些规则可以实现基于权重的比例流量分发、灰度验证、金丝雀发布、按请求参数的路由、同区域优先、超时配置、重试、限流降级等能力。
            service mesh 控制面。。。
        （2） Dubbo数据面：据面代表集群部署的所有 Dubbo 进程，进程之间通过 RPC 协议实现数据交换
            服务消费者 (Dubbo Consumer)，发起业务调用或 RPC 通信的 Dubbo 进程
            服务提供者 (Dubbo Provider)，接收业务调用或 RPC 通信的 Dubbo 进程

    Dubbo & gRPC
        Dubbo 与 gRPC 最大的差异在于两者的定位上：
            （1） gRPC 定位为一款 RPC 框架，Google 推出它的核心目标是定义云原生时代的 rpc 通信规范与标准实现；
            （2） Dubbo 定位是一款微服务开发框架，它侧重解决微服务实践从服务定义、开发、通信到治理的问题，因此 Dubbo 同时提供了 RPC 通信、与应用开发框架的适配、服务治理等能力。

    基于 TCP 的 Dubbo2 协议， 基于 HTTP/2 的 Triple 协议

RPC 异步处理：
    为什么需要：
        因为耗时主要是业务处理（比如DB查询）而不是处理请求的过程， 通过异步方式提升业务处理的吞吐量，作为一个高性能的RPC 框架必须要做到异步化，这样可以极大的提升整体吞吐量。
    如何实现：
        RPC 框架的异步策略主要是调用端异步与服务端异步。
        (1) 调用端的异步就是通过 Future 方式实现异步，调用端发起一次异步请求并且从请求上下文中拿到一个 Future，之后通过 Future 的 get 方法获取结果，如果业务逻辑中同时调用多个其它的服务，则可以通过 Future 的方式减少业务逻辑的耗时，提升吞吐量。
        (2) 服务端异步则需要一种回调方式，让业务逻辑可以异步处理，之后调用 RPC 框架提供的回调接口，将最终结果异步通知给调用端。这样就实现了RPC调用的全异步。



Thrift: facebook开源的，包含序列化功能和支持服务通信的RPC框架，主要包含三大部分：代码生成、序列化框架、RPC框架
    特点：
        轻量级

gRPC: 谷歌开源的， 基于http2 和 使用 ProtoBuf 作为序列化工具和接口定义语言（IDL），支持多语言开发











    



