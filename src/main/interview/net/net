IO 多路复用：multiplexing
    一些概念：
        reactor模式->事件驱动
        IO有内存IO、网络IO和磁盘IO三种，通常我们说的IO指的是后两者： 通常用户进程中的一个完整IO分为两阶段：用户进程空间<-->内核空间、内核空间<-->设备空间（磁盘、网络等）
        IO操作包含两个过程：（1） 等待数据准备,数据是否拷贝到内核缓冲区 （2）将数据从内核拷贝到用户进程空间
        同步IO：进程在获取IO结果前不能做其他事情， 只能等待或者轮询内核IO操作完成后才能继续
            （1）阻塞IO： 进程发起IO系统调用后，进程被阻塞，转到内核空间处理，整个IO处理完毕后返回进程。操作成功则进程获取到数据。
                -> 仅使用并发量不高的场景， 因为需要为每一个请求都开启一个处理线程。
                case：阻塞socket、Java BIO
            （2）非阻塞IO：进程发起IO系统调用后，如果内核缓冲区没有数据，需要到IO设备中读取，进程返回一个错误而不会被阻塞；进程发起IO系统调用后，如果内核缓冲区有数据，内核就会把数据返回进程。
                case: socket是非阻塞的方式（设置为NONBLOCK）
            （3）IO多路复用：

            （4）信号驱动IO：注册一个IO信号事件，在数据可操作时通过SIGIO信号通知线程，（某种程度上也这可以算是一种异步机制）

        异步IO： 异步是指用户线程发起IO请求后仍继续执行，当内核IO操作完成后会通知用户线程，或者调用用户线程注册的回调函数
            case： linux 或者Java上的AIO
    多路复用技术的优点：
        （1）一个进程维护负责多个网络连接，系统开销小。

    SELECT：
        过程机制：
            （1）已连接的 Socket 都放到一个文件描述符集合中
            （2）调用 select 函数将文件描述符集合拷贝到内核里，让内核来检查是否有网络事件产生， 标记为可读或者可写
            （3）把整个文件描述符集合拷贝回用户态里，然后用户态还需要再通过遍历的方法找到可读或可写的 Socket，然后再对其处理
        限制：
            select 使用固定长度1024位的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 1024，只能监听 0~1023 的文件描述符，这也就是select方式有检测连接上限最底层的原因。
        问题：
            两次复制，性能差， 可以考虑内存优化（共享内存）
            返回的是就绪的个数，用户层还需要遍历， 不如直接给就绪的文件描述符
            遍历也是性能影响的重点， 可以通过事件回掉来优化
    POLL：
        poll使用动态数组，以链表形式来组织文件描述符， 数量限制没有了。
        poll 和 select 并没有太大的本质区别，都是使用线性结构存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合。这样的方式，在大规模请求下，性能会急剧下降。

    EPOLL：目前主流的
        （1）首先，epoll 在内核里使用红黑树来跟踪进程所有待检测的文件描述字，把需要监控的 socket 通过 epoll_ctl() 函数加入内核中的红黑树里，通过对黑红树进行操作，这样就不需要像 select/poll 每次操作时都传入整个 socket 集合，只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。
        （2）epoll 使用事件驱动的机制（而不是select的轮询）内核里维护了一个链表来记录就绪事件，当某个 socket 有事件发生时，通过回调函数会将其加入到这个就绪事件列表中，当用户调用 epoll_wait() 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。

        优化点：
            （1）内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可
            （2）内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒。
            （3）内核仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合。



    使用IO多路复用的场景：
        redis 、 netty 、
    https://www.cnblogs.com/flashsun/p/14591563.html





