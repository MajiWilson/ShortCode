

当键入网址后，到网页显示，其间发生了什么
    （1） 浏览器解析URL
    （2） 生成HTTP请求消息（格式）
    （3） DNS查询域名对应IP地址： DNS服务器包括根、顶级、权威、本地域名服务器等
            （1）自己没有缓存的话， 就让本地域名服务器（客户端的 TCP/IP 设置中填写的 DNS 服务器地址）受理
            （2）查询其本地缓存， 没有则查询根
            （3）根告诉应该从哪里查询....
    （4）获取IP后，委托操作系统发送消息， 基于其协议栈分别是：
            （1）Socket库
            （2）传输协议： TCP/UDP ，收发数据：
                    （1）TCP报文：
                        源端口号： 16位
                        目的端口号：
                        序号： 解决包的乱序问题
                        确认序号：解决丢包的问题,期望收到的下一个序列号
                        状态位： SYN（发起连接）、ACK（回复）、RST（重新连接）、FIN（结束连接）
                        窗口大小： 流量控制、拥赛控制， 标识处理能力和控制发放速度

                    （2）三次握手：
                        客户端和服务端都是Closed状态：
                        客户端发送SYN，处于SYN_SENT状态
                        服务端监听到消息好发送SYN+SCK， 并确认序列+1， 处于SYN-RCVD状态
                        客户端发送ACK， 建立连接， 状态为ESTABLISHED
                        服务端口收到确认后， 也改成ESTABLISHED状态

                    （3）查询TCP状态的指令：
                        netstat -napt

                    （4）TCP报文数据包括：
                        HTTP 头部
                        数据


            （3）IP协议： TP\ICMP、ARP， 控制网络包收发操作、于告知网络包传送过程中产生的错误以及各种控制信息、用于根据 IP 地址查询相应的以太网 MAC 地址
                    （1）IP报文格式：
                        版本
                        首部长度
                        服务类型
                        总长度
                        标识：
                        标志：
                        片偏移
                        TTL:
                        协议： TCP或者UDP
                        首部校验和：
                        源IP地址：
                        目标IP地址：
                        选项：
                        数据：
                    （2） 查看当前系统的路由表指令：
                        route -n

                    （3）接口层帧格式：
                        接受方MAC地址： 48位
                        发送方MAC地址：
                        协议类型； IP/ARP

            （4）网络驱动程序：控制网卡
                我们需要将数字信息转换为电信号，才能在网线上传输，也就是说，这才是真正的数据发送过程
            （5）物理硬件网卡

            其他：
                （1）包含TCP和IP头部的数据包最大是1500字节， TCP数据部分最大值更小。

    (5) 经由交换机： 负责将网络报原样传递到目的地，交换机上没有MAC地址，但是会记录MAC地址应该发送到哪个端口的信息， 网络中的计算机只会处理发给自己的网络报，不是发给自己的将被忽略。
   （6）经由路由器：三层网络涉笔， 具备MAC地址和IP地址， 和计算机的网卡是类似的
            源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址
   （7）服务端接受到数据包后根据协议确定上层协议为TCP， 然后监听端口的进程进行处理， 然后发现是HTTP请求需要访问某个界面， 因此将请求发给HTTP进程，并构建返回数据包发给客户。



HTTP:
        (1) 状态：
            1XX: 属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。
            2XX: 表示服务器成功处理了客户端的请求
                200 OK: 成功
                204 No Content： 成功， 但是相应的头没有BODY数据
                206 Partial Content 是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。
            3XX：表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源
                301 Moved Permanently： 永久重定向， 新URL在location字段中
                302 Found： 临时重定向， 新URL在location字段中
                304 Not Modified： 不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。
            4XX： 表示客户端发送的报文有误，服务器无法处理
                400 Bad Request： 表示客户端请求的报文有错误，但只是个笼统的错误
                403 Forbidden： 表示服务器禁止访问资源，并不是客户端的请求出错。
                404 Not Found： 表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。
            5XX： 表示客户端请求报文正确，但是服务器处理时内部发生了错误
                500 Internal Server Error: 与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。
                501 Not Implemented: 表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思
                502 Bad Gateway: 通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
                503 Service Unavailable: 表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。
        (2) 常见字段：

                host: 客户端发送请求时， 指定发送者的域名
                Content-Length： 服务端返回数据的长度
                        HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题
                Connection： 客户端要求服务器使用「HTTP 长连接」机制时候填 keep-alive
                        HTTP 的 Keep-Alive，是由应用层（用户态） 实现的，称为 HTTP 长连接： 一个 HTTP 请求完后，先不断开 TCP 连接，让后续的 HTTP 请求继续使用此连接
                        实际上也会设置一个定时器来避免长时间没有请求的情况

                        TCP 的  Keep-Alive， TCP 保活机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活，这个工作是在内核完成的。

                Accept: 客户端请求的时候指明接受哪些数据类型 */* 不限制
                Content-Type：服务器返回数据的类型
                Content-Encoding： 服务器返回数据的压缩格式
                Accept-Encoding： 客户端请求指定自己接受的压缩格式
                Origin:   用于指明当前请求来自于哪个站点
                Referer:  告诉服务器该网页是从哪个页面链接过来的，服务器因此可以获得一些信息用于处理
                Cookie：
                Cache-Control： 是否使用缓存和使用缓存的机制 no-cache
        （3） 方法：
            GET 的语义是请求获取指定的资源。GET 方法是安全、幂等、可被缓存的。
            POST 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST 不安全，不幂等，（大部分实现）不可缓存。

        （4） HTTPS：解决了窃听、串改、冒充的风险
                HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
                HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
                HTTP 默认端口号是 80，HTTPS 默认端口号是 443。
                HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

               安全的依赖是：
                    信息加密 ： 混合加密的方式实现信息的机密性，解决了窃听的风险。
                        在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密
                        通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。
                    校验机制 ： 摘要算法的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。
                            使用哈希算法将数据内容计算得到一个指纹， 接受方收到数据后重新计算指纹一致，但是这个指纹不一定不能被替换，所以引入了数字签名保证来源可靠性
                            通过非对称加密算法， 私钥加密， 公钥解密，防止冒名顶替， 加密的内容是哈希值

                            如果选择公钥加密，私钥解密则一般是是为了安全传输，
                    身份证书 ： 将服务器公钥放入到数字证书中，解决了冒充的风险。
                            （1）服务器把自己的公钥注册到CA， CA用自己的私钥生成数字证书，（包含服务器的公钥）
                            （2）客户端拿到服务器的数字证书以后， 使用CA的公钥确认其真实性， 获取服务器的公钥， 然后利用公钥来进行报文发送
                            （3）服务器接受到消息后， 使用自己的私钥来解密即可。

               HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全。





WebSocket： 网络通信协议
       虽然TCP是全双工的， 但是HTTP是半双工的， 同一时间只能是一方发送消息一方接受，
       HTTP这样设计的原因是因为， 开始没有考虑到网页层面会有大量频繁交互。因此引入了websocket， 一般网页游戏使用的就是这个协议， 也是一个利用TCP的上层协议
       在 HTTP/1.1 里，只要客户端不问，服务端就不答。基于这样的特点，对于登录页面这样的简单场景，可以使用
        （1）定时轮询（
            以 Web 应用通过通过频繁的异步 JavaScript 和 XML (AJAX) 请求来实现轮循
       （2）或者长轮询的方式实现服务器推送(comet)的效果。
       （3）流的方式， iframe

       想使用websocket，需要 HTTP 请求里带上一些特殊的header 头：
            Connection: Upgrade ； 表示升级协议
            Upgrade: WebSocket ： 升级的协议
            Sec-WebSocket-Key: T2a6wZlAwhgQNqruZ2YUyg==\r\n   ：随机生成的 base64 码
       如果服务器支持websocket协议的话， 则会进行websocket握手协议：返回101状态：（协议切换）
            HTTP/1.1 101 Switching Protocols\r\n
            Sec-WebSocket-Accept: iBJKv/ALIW2DobfoA4dmr3JHBCY=\r\n
            Upgrade: WebSocket\r\n
            Connection: Upgrade\r\n
       这样两次握手之后就可以使用websocket交互了， 格式也是 消息头（含有长度信息） + 消息体的格式， 并提供了解决粘包的问题

       它适用于需要服务器和客户端（浏览器）频繁交互的大部分场景，比如网页/小程序游戏，网页聊天室，以及一些类似飞书这样的网页协同办公软件。


TCP：
        （1） IP协议是不可靠的， 因为不摆正网络包交付、按序交付和数据的完整性， 因此依赖TCP协议来保证接收的网络包是无损坏、无间隔、非冗余和按序的。
             提供可靠的数据传输服务
        （2）这个连接，其实是保证可靠性和流量控制维护的某些状态信息，包括socket、状态信息、序列号、窗口大小等
        （3）UDP格式：
                源端口
                目标端口
                包长度
                校验和
            UDP即可发送， 不需要建立连接先，支持1对多的通信， 首部只有8字节， TCP如果没有使用选项固定是20字节
            主要用于包数据较少或者视频音频通信等比如DNS、SNMP、广播等
        （4）第三次握手是可以携带数据的
        （5）三次握手的原因：保证双方都具备处理和发送的能力
                （1）避免对已经失效的历史连接请求初始化造成混乱和浪费资源（每次TCP连接的初始随机需要是不同的来区别， 时间+ MD5）
                （2）同步双方的序列号
                （3）三次是至少的，更多就浪费资源了
        (6)为什么IP层会根据MTU（一个网络包的最大长度）分片，还需要TCP上协商双方传输的MSS（除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度）呢
            因为这样TCP层的分片，可以避免在IP层分片产生的问题：如果有一个IP包丢失， 需要重传这些分片的所有IP数据包）

        （7）第一次握手失败后， 客户端重试（有次数限制），最终断开连接， 第二次握手失败后，双方都会重传， 第三次握手失败后， 服务端会重传

        （8）SYN攻击：短时间伪造大量IP建立连接， 但是不对服务端的SYN+AKC进行回复， 服务端产生大量的半连接， 当 TCP 半连接队列满了，后续再在收到 SYN 报文就会丢弃，导致客户端无法和服务端建立连接。
            避免方法：
                增大半连接队列的长度
                调大 netdev_max_backlog
                开启 tcp_syncookies： 可以不实用这个半连接队列直接建立连接，
                减少 SYN+ACK 重传次数：可以快速重试几次后就释放半连接（5-》1次）
        （9）四次挥手：
                    （1） 客户端发起断开连接； FIN， 状态为FIN_WAIT_1
                    （2） 服务端发回ACK， 状态为CLOSED_WAIT, 客户端状态为FIN_WAIT_2， 客户端已经单向关闭
                    （3） 服务端发起断开连接；FIN， 状态为LAST_ACK
                    （4） 客户端发回ACK， 状态改成TIME_WAIT, (是主动关闭的进入等待状态）
                    （5） 服务端收到ACK后， 状态为CLOSE,
                    （6） 客户端发送ACK后， 再等待2个MSL 时间后状态为CLOSE
           等待两个最大报文存活时间， 这样设计，
                （1）可以保证本连接双向上的所有数据包都被丢弃，后面相同端口IP连接的数据一定是新连接产生的， 不会产生干扰
                （2）同时也可以确保ACK报文成功给服务器收到，确保关闭正常
        （10）socket编程过程：
                （1）服务端：
                        初始化socket
                        bind，将 socket 绑定在指定的 IP 地址和端口
                        listen, 监听
                        accept: 等待客户端连接， 成功返回是在第三次握手后
                                accept实际上没有参与握手，而是从 TCP 全连接队列取出一个已经建立连接的 socket，用户层通过 accpet 系统调用拿到了已经建立连接的 socket，就可以对该 socket 进行读写操作了。
                        write, read
                        close
                （2）客户端：
                        初始化socket
                        connect: 发起三次握手， 成功返回是第二次握手后
                        write\read
                        close
        （11）重传机制：
                （1）超时重传：当数据包丢失或者接收方ack丢失（超过超时重传时间RTO），重发数据包， 超时重传时间 RTO 的值应该略大于报文往返 RTT 的值。平衡效率和错误的重传
                        RTT时间是一个动态计算的值， 会根据网络用赛情况变化
                （2）快速重传：当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。说明之前有一个数据包一直没有被ACK，但是这里还有一个问题， 重传是只传送一个还是失败后的所有数据呢，
                        引入了选择性确认的机制（ASACK)
                        这种方式需要在 TCP 头部「选项」字段里加一个 SACK 的东西，它可以将已收到的数据的信息发送给「发送方」，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。
        (12)滑动窗口（流量控制）
                （1）作用：窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。主要是为了提高数据传输效率， 不用每次发送数据后需要收到确认后才能进行下一次发送
                （2）这样维护一个缓存空间， 确认后才可以从缓存区中清楚
                （3）并且可以支持累积应该， 也就是中间的数据包ACK丢失了， 后面的ACK收到了也可以
                （4）窗口的大小是由接收方的窗口大小来决定的。因为不能超处接受者的处理能力， 接收窗口的大小是约等于发送窗口的大小的
        （13） 拥塞控制：避免发送方数据填满整个网络
            拥塞窗口 cwnd是发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化的， 实际发送窗口应该是取拥塞窗口和接受窗口的最小值
            当发生拥赛时候（超时重传），CWND减小反之增加， 主要涉及算法四个
                 （1）慢启动：
                        当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1， 指数增加
                 （2）拥塞避免：
                        当指数增加超过门限值后，改成线性增长
                 （3）拥塞发生：
                        超时重传则门限值设置为cwnd/2， 用赛窗口=1
                        快速重传则门限值 = cwnd， 拥塞窗口减半, 摒弃进行快速回复
                 （4）快速回复

网络抓包的工具：
    tcpdump 和 Wireshark，
    tcpdump 仅支持命令行格式使用，常用在 Linux 服务器中抓取和分析网络包。
    Wireshark 除了可以抓包外，还提供了可视化分析网络包的图形页面。






















